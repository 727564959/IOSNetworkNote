## 缓存解决的问题

1. 冗余数据传输
2. 带宽瓶颈
3. 瞬间拥塞
4. 距离时延

## 缓存命中

### HTTP再验证

原始服务器的内容可能发生变化，缓存要随时进行新鲜度查询。大部分缓存会在客户端发起请求，且副本旧得需要检测时，才会对副本进行验证。

缓存对副本进行验证时，会向原始服务器发送一个小的验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。缓存知道副本任然有效，就会对其做标记，并将副本提供给客户端，这被称作**再验证命中**或**缓存命中**。客户端通常使用If-Modified-Since首部做为验证工具。

服务器收到GET If-Modified-Since时的情况：

- 再验证命中

  服务器以304 Not Modified进行响应。

- 再验证未命中

  服务器向客户端发送一条带有完整内容的HTTP 200 OK响应。

- 对象被删除

  服务器上的对象已被删除，回送一个404 Not Found 响应，缓存也将其副本删除。

## 副本新鲜度

### 文档过期

HTTP通过Cache-Control首部和Expires首部向每个文档附加了一个"过期日期",在缓存文档过期之前，缓存可以以任意频率使用这些副本，无需与服务器联系(客户端请求可以包含阻止提供已缓存或未验证资源的首部)。但一旦已缓存文档过期，缓存就必须与服务器进行核对。

> Cache-Control:max-age	max-age值定义类文档的最大使用期，即相对日期。
>
> Expires							   指定一个绝对的过期日期

仅仅是文档过期了并不意味着它和服务器上目前处于活跃状态的文档有实际区别，只是意味着到核对时间了。

如果再验证显示内容发送了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。反之，缓存只获取新的首部，包括一个过期日期，并对缓存中的首部进行更新。

### 条件方法验证

判断服务器上的内容是否被修改.

> If-Modified-Since:<date>	如果从指定日期之后文档被修改过了，就执行请求方法。
>
> If-None-Match:<tags>		服务器可以为文档提供特殊标签(ETag)，这些标签就像序列号一样，如果已缓存标签与服务器文档中的标签有所不同，If-None-Match首部就会执行所请求的方法.

#### If-Modified-Since局限

- 有些文档可能会被周期性的重写,但实际内容并未改变,日期却发生变化.
- 文档被做了不必要的修改,如拼写和日期的修改.
- 有些服务器无法判定其页面的最后修改日期
- 有些服务器提供的文档会在亚秒间隙发生变化.

## 缓存的拓扑结构

**私有缓存**：通常指用户的磁盘空间。

**公有缓存**：特殊的共享代理服务器（代理缓存）。

### 层次化缓存

在靠近客户端的地方使用小型廉价缓存，而更高层次中使用更大、功能更强的缓存来装载用户共享文档。

在这种结构中较小的缓存未命中会被导向较大的父缓存。若缓存的层次结构较深，请求可能会穿过很长一段缓存，但每个拦截代理会添加一些性能损耗，当代理链路很长时，性能损耗会十分明显。

### 网状缓存

**内容路由**：能决定选择何种路由对内容进行访问、管理和传送的代理缓存。

## 缓存控制

> no-cache		不管本地副本是否过期,在与原始服务器进行新鲜度在验证之前，缓存不能将其提供给客户端使用。
>
> no-store		禁止缓存对响应进行复制，缓存会向客户端转发一条no-store响应，并删除对象。
>
> max-age		此文档处于新鲜状态的秒数。将其置为0代表每次访问刷新。
>
> s-maxage	行为与max-age一致，但仅适用于共享缓存。
>
> Expires		指定实际的过期日期。HTTP设计者认为，由于很多服务器时钟不同步，所以最好使用剩余秒数而不是绝对时间。
>
> must-revalidate	本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。
>
> max-stale		缓存可以随意提供过期文件。如果指定参数，在这段时间内，文档不能过期。
>
> min-fresh		在至少未来的x秒内文档要保持新鲜。
>
> only-if-cached	只有当缓存中有副本存在时，客户端才会获取一份副本。